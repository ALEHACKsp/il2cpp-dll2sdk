using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using dnlib.DotNet;

namespace Dll2Sdk
{
    class Program
    {
        static void Main(string[] args)
        {
            var a = Directory.GetFiles(args[0]);
            
            var modCtx = ModuleDef.CreateModuleContext();
            var asmResolver = (AssemblyResolver)modCtx.AssemblyResolver;
            var modules = a.Select(p => ModuleDefMD.Load(p, modCtx)).ToArray();

            foreach (var dll in modules)
                asmResolver.AddToCache(dll);

            var typeRefs = new Dictionary<string, List<TypeRef>>();
            foreach (var module in modules)
            {
                foreach (var typeRef in module.GetTypeRefs())
                {
                    var tf = typeRef.ResolveTypeDef();
                    if (tf != null)
                    {
                        if (!typeRefs.TryGetValue($"{typeRef.DefinitionAssembly.Name}_{tf.FullName}", out var l))
                        {
                            l = new List<TypeRef>();
                            typeRefs.Add($"{typeRef.DefinitionAssembly.Name}_{tf.FullName}", l);
                        }
                        l.Add(typeRef);
                    }
                }
            }

            foreach (var module in modules)
            {
                var typesToUnNest = new Stack<TypeDef>();
                foreach (var type in module.Types)
                {
                    foreach (var nestedType in type.NestedTypes)
                    {
                        typesToUnNest.Push(nestedType);
                    }
                }

                while (typesToUnNest.Count > 0)
                {
                    var t = typesToUnNest.Pop();
                    var dt = t.DeclaringType;

                    if (!typeRefs.TryGetValue($"{t.DefinitionAssembly.Name}_{t.FullName}", out var l))
                    {
                        l = new List<TypeRef>();
                    }

                    t.Name = $"{dt.Name}_{t.Name}";
                    t.Namespace = dt.Namespace;
                    t.DeclaringType = null;

                    if (t.IsEnum)
                    {
                        t.GenericParameters.Clear();
                    }

                    module.Types.Add(t);

                    foreach (var t2 in l)
                    {
                        t2.Name = t.Name;
                        t2.Namespace = t.Namespace;
                        t2.ResolutionScope = module;
                        t2.ResolveTypeDefThrow();
                    }

                    foreach (var st in t.NestedTypes)
                    {
                        typesToUnNest.Push(st);
                    }
                }
            }
            
            Directory.CreateDirectory("out/DLL2SDK");
            File.WriteAllText("out/DLL2SDK/dll2sdk_forward.g.hpp", @"//generated by dll2sdk
#pragma once
#include <cstdint>

#include ""il2cpp.hpp""

namespace DLL2SDK
{
    inline uintptr_t GameAssemblyBase;

    struct Class
    {
        Il2CppClass_1 _1;
        void* StaticFieldsPtr;
        Il2CppClass_2 _2;
        VirtualInvokeData VTable[0];
    };

    struct Object
    {
        Class* ClassPtr;
        void* Monitor;
    };

    template<typename T>
    struct Array
    {
        Object Object;
        void* Bounds;
        size_t Length;
        T Items[0];
    };
}

");

            var corlib = modules.First(m => m.Name.Contains("mscorlib"));
            foreach (var dll in modules)
            {
                new SdkGenerator(dll, corlib.Assembly);
            }
            
            Console.WriteLine("done!");
        }
    }
}