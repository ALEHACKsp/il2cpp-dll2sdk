using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using CommandLine;
using Dll2Sdk.Utils;
using dnlib.DotNet;

namespace Dll2Sdk
{
    internal static class Program
    {
        public static Options Arguments;
        private static void Main(string[] args)
        {
            // Parse commands

            Parser.Default.ParseArguments<Options>(args).WithParsed(_opts => Arguments = _opts);

            if (Arguments == null)
            {
                Console.ReadKey();
                return;
            }

            if (!Directory.Exists(Arguments.DummyDllPath))
            {
                Parser.Default.ParseArguments<Options>(Array.Empty<string>()).WithParsed(_opts => Arguments = _opts);
                Console.ReadKey();
                return;
            }

            var a = Directory.GetFiles(Arguments.DummyDllPath);

            var modCtx = ModuleDef.CreateModuleContext();
            var asmResolver = (AssemblyResolver)modCtx.AssemblyResolver;
            var modules = a.Select(p => ModuleDefMD.Load(p, modCtx)).ToArray();
            //modules = modules.OrderByDescending(x => x.Assembly.Name == "System");

            foreach (var dll in modules)
                asmResolver.AddToCache(dll);

            var typeRefs = new Dictionary<string, List<TypeRef>>();
            foreach (var module in modules)
            {
                foreach (var typeRef in module.GetTypeRefs())
                {
                    var tf = typeRef.ResolveTypeDef();
                    if (tf != null)
                    {
                        if (!typeRefs.TryGetValue($"{typeRef.DefinitionAssembly.Name}_{tf.FullName}", out var l))
                        {
                            l = new List<TypeRef>();
                            typeRefs.Add($"{typeRef.DefinitionAssembly.Name}_{tf.FullName}", l);
                        }
                        l.Add(typeRef);
                    }
                }
            }

            foreach (var module in modules)
            {
                static void GetNestedTypes(ref Stack<TypeDef> stack, IList<TypeDef> defs)
                {
                    foreach (var type in defs)
                    {
                        GetNestedTypes(ref stack, type.NestedTypes);
                    }
                }

                var typesToUnNest = new Stack<TypeDef>();
                //GetNestedTypes(ref typesToUnNest, module.Types);
                foreach (var type in module.Types)
                {
                    foreach (var nestedType in type.NestedTypes)
                    {
                        typesToUnNest.Push(nestedType);
                    }
                }

                //var declaringTypes = new Dictionary<TypeDef, TypeDef>();

                while (typesToUnNest.Count > 0)
                {
                    var t = typesToUnNest.Pop();
                    var dt = t.DeclaringType;


                    if (!typeRefs.TryGetValue($"{t.DefinitionAssembly.Name}_{t.FullName}", out var l))
                    {
                        l = new List<TypeRef>();
                    }

                    t.Name = $"{dt.Name}_{t.Name}";
                    t.Namespace = dt.Namespace;
                    t.DeclaringType = null;

                    if (t.IsEnum)
                    {
                        t.GenericParameters.Clear();
                    }

                    module.Types.Add(t);

                    foreach (var t2 in l)
                    {
                        t2.Name = t.Name;
                        t2.Namespace = t.Namespace;
                        t2.ResolutionScope = module;
                        t2.ResolveTypeDefThrow();
                    }

                    foreach (var st in t.NestedTypes)
                    {
                        typesToUnNest.Push(st);
                    }
                }
            }

            Directory.CreateDirectory(Arguments.OutDirectory);
            File.WriteAllText($"{Arguments.OutDirectory}/dll2sdk_forward.g.hpp", @"//generated by dll2sdk
#pragma once
#include <cstdint>

#include ""il2cpp.hpp""

namespace DLL2SDK
{
    inline uintptr_t GameAssemblyBase;

    #pragma warning(disable : 4200)
    struct Class
    {
        Il2CppClass_1 _1;
        void* StaticFieldsPtr;
        Il2CppClass_2 _2;
        VirtualInvokeData VTable[0];
    };

    struct Object
    {
        Class* ClassPtr;
        void* Monitor;
    };

    template<typename T>
    struct Array
    {
        Object Object;
        void* Bounds;
        size_t Length;
        T Items[0];
    };
}

");

            var corlib = modules.First(m => m.Name.Contains("mscorlib"));
            foreach (var dll in modules)
            {
                new SdkGenerator(dll, corlib.Assembly, args);
            }

            var il2cpp = File.ReadAllText("il2cpp.h").Replace("bool thread_local;", "bool _thread_local;").Trim() + Environment.NewLine;
            File.WriteAllText($"{Arguments.OutDirectory}/il2cpp.hpp", il2cpp);
            Console.WriteLine("\nPress any key to exit...");
            Console.ReadKey(true);
        }
    }
}
